\documentclass[conference]{IEEEtran}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{pgfplotstable}
\pgfplotsset{compat=1.12}
\usepackage{booktabs}

\usepackage{enumitem}
\setlist{parsep=0pt, listparindent=0.5cm}

\title{A Comparison of Parallel Graph Processing Platforms}
\author{
	\IEEEauthorblockN{Samuel Pollard}
	\IEEEauthorblockA{Department of Computer and Information Science \\
		University of Oregon \\
		Eugene, OR, USA \\
		Email: spollard@cs.uoregon.edu
	}
	\and
	\IEEEauthorblockN{Boyana Norris}
	\IEEEauthorblockA{Department of Computer and Information Science \\
	University of Oregon \\
	Eugene, OR, USA \\
	Email: norris@cs.uoregon.edu
	}
}

\begin{document}
\maketitle
\begin{abstract}
This is a survey of existing graph analytics frameworks.
\end{abstract}

\section{Introduction}

[Talk about WHY we care about graph processing, and parallel in particular. Talk about what parallel graph processing is.]

Our research is motivated by the current state of parallel graph processing. The most comprehensive survey, released in 2014, identified and taxonomized over 80 different parallel graph processing systems \cite{Doekemeijer:2015:GPFSurvey}. These systems operate with a wide range of parallelism paradigms such as GPU [Medusa], shared memory [pretty much everything], a combination of CPU and GPU \cite{Gharaibeh:2012:Totem}, distributed database querying, \cite{Rodriguez:2015:Gremlin}, distributed filesystem based approaches \cite{Xin:2013:GraphX}, distributed memory with MPI [cite], domain-specific languages [Green Marl], as well as novel communication schemes [activemessages, sockets].

Since 2014, the problem has compounded with the addition of even more proprietary and open source projects such as \cite{Cheramangalath:2015:Falcon}, \cite{Perez:2015:Ringo} [name some more]. At the outset, this plethora of choices makes the question, ``which system is the best for my problem?'' incredibly difficult. There has even been a propagation of so-called ``reference implementations'' which provide implementations of the most common graph algorithms [GAP, GraphBIG]. Thus, even selecting a standard and a benchmark over which to compare various implementations is nontrivial. To quote Andrew Tanenbaum, ``The nice thing about standards is that you have so many to choose from.''

Another issue with the parallel graph processing library designers is the lack of comprehensive comparison. One possible reason for this is the considerable effort of getting each library and package to work, satisfying dependencies, and ensuring the data is in the correct format for each system. Beyond this, each system may have a different method of measuring performance. Thus, one of the contributions of this paper is to provide a ``level playing field'' for each graph processing system. Graphalytics \cite{Capota:2015:Graphalytics} attempts to remedy this but has not seen widespread adoption.

%This paper aims to make that selection process just a little easier.

\section{Machine Specifications}
Table~\ref{tab:specs} shows the specifications of the research computer (named Arya).

\begin{table}[!htb]
	\centering
	% Keep in mind you can do this at the beginning: string replace={s1}{s2}
	\pgfplotstabletypeset[
	header=false,
	col sep=tab,
	string type,
    every head row/.style={output empty row, before row=\bottomrule},
	columns/0/.style={column type={|r|}},
	columns/1/.style={column type={l|}},
	every last row/.style={after row=\toprule},
	]{../report/specs.csv}
	\caption{Machine specifications. The disparity between the CPU's advertised clock speed and the ``CPU Clock'' row is a result of the Turbo Boost technology which can increase the clock speed to a limit. The manufacturer's published maximum clock speeds can be found at \url{http://ark.intel.com}.}
	\label{tab:specs}
\end{table}

\begin{table}[htb]
	\centering
	\begin{tabular}{l|c|c|c}
			& BFS & SSSP & PR \\ \hline
		Graph500 & & & \\ \hline
		PBGL  & & & \\ \hline
		GAP  & & & \\ \hline
		GraphBIG  & & & \\ \hline
		Galois  & & & \\ \hline
		PowerGraph  & & &
	\end{tabular}
	\caption{Performance. Note that implementations of every algorithm are not availabe for every platform.}
	\label{tab:reportcard}
\end{table}

\section{Algorithms and Systems}
The canonical performance leaderboard for paralell graph processing is the Graph500 \cite{Murphy:2010:Graph500}. The advantage of the Graph500 is it provides standardized measurement requirements and dataset generation. The primary drawback with using reference implementations for the Graph500 is the standard only supports a single algorithm: breadth first search.

This report explores a small sample of the existing graph processing platforms with a focus on the so-called ``reference implementations:'' the Graph500 (from \url{http://www.graph500.org}), GAP \cite{Beamer:2015:GAPBench}, and GraphBIG \cite{Nai:2015:Graphbig}. Parallel Boost Graph Library \cite{Gregor:2005:PBGL} and PowerGraph \cite{Gonzalez:2012:Powergraph} implementations are also provided because of their popularity and the availability of high quality reference implementationsF.

\section{Performance}
Graphalytics without the use of the Granula plugin produces performance measurement in two forms: runtime in seconds and traversed edges per second.

%Table~\ref{tab:perf} lists performance in milliseconds of runtime according to the graphalytics output. Graphalytics also outputs MTEPS or millions of traversed edges pers econd. However, the graphalytics version does not make sense in all cases: for example, computing the local clustering coefficient involves traversing each edge multiple times (proportional to the sparsity of the graph), while breadth first search (BFS) traverses each edge exactly once, and on na\:ive implementations single-source shortest paths (SSSP) may have $O(|E| + |V|^2)$ traversed edges.
% TODO: Cite Comer algorithm book for Dijkstra's algorithm runtime.

In Table~\ref{tab:perf}, BFS is breadth-first search, SSSP is single-source shortest paths, LCC is local clustering coefficient, PR is PageRank, CDLP is community detection using label propagation, and WCC is weakly connected components. For the algorithms used, see \cite{Iosup:2016:Graphalyticstech}.

% TODO: This should be unnecessary once autogeneration is used.
\begin{table}[!htb]
	\centering
%	\begin{tabular}{l|r|r|}
%	 & PowerGraph & OpenG \\ \hline
%	BFS & 81.8 & 341 \\ \hline
%	SSSP & 1.64 & 15.0 \\ \hline
%	LCC & 54.6 & 142 \\ \hline
%	\end{tabular}

		\centering
		\pgfplotstabletypeset[
			col sep=comma,
			string type, % Makes the .style={string type} redundant
			columns={[index]0,openg,powergraph},
			every head row/.style={after row=\midrule},
			columns/0/.style={string type, column type={l|}, column name={}},
			columns/openg/.style={string type, column type={r}},
			columns/powergraph/.style={string type, column type={r}}
		]{../report/runtime.csv}
	\caption{Performance Results for the \texttt{dota-league} dataset with 61,670 vertices and 50,870,313 edges.}
	\label{tab:perf}
\end{table}

\section{Graph Processing Taxonomy}
This is in the spirit of \cite{Doekemeijer:2015:GPFSurvey}. Here, ``|'' means ``or'' and ``+'' means ``and.'' FOSS means Free and Open Source Software. The quotes around ``yes'' for HPC mean that the product claims to be amenable to high performance computing. Whether these actually achieve their goal is one of the purposes of this project.
\begin{table*}[t]
	\begin{minipage}{\linewidth} % So the footnotes all get printed on the same page
		\centering
		%\small
		\pgfplotstabletypeset[
			col sep=comma,
			string type, % Makes the .style={string type} redundant
			columns={Name,Type,HPC,Parallelism,Target,FOSS,Source,Notes},
			every head row/.style={after row=\midrule},
			columns/Name/.style={string type, column type={l|}},
			columns/Type/.style={string type},
			columns/HPC/.style={string type},
			columns/Parallelism/.style={string type},
%			columns/Comm./.style={%
%				string type,
%				postproc cell content/.style={%
%					@cell content/.add={\footnotesize}
%				}
%			},
			columns/Target/.style={string type},
			columns/FOSS/.style={string type},
			columns/Source/.style={string type},
			columns/Notes/.style={
				preproc cell content/.style={@cell content=
					\ifx&##1&% Only make a footnote if the cell is nonempty
						##1
					\else
						\footnote{##1}
					\fi}
			},
		]{../report/platforms.csv}
		\caption{Tools used for graph processing}
		\label{tab:frameworks}
	\end{minipage}
\end{table*}


\section{Conclusion} % Begin with the end in mind...
We have presented an updated survey of parallel graph processing frameworks supplementary to \cite{Doekemeijer:2015:GPFSurvey}. From this, we have selected a representative subset of frameworks on which performance is analyzed and have stored these results in a database. To facilitate parallel graph processing, hardware information and performance results are automatically populated (as were all the tables in this paper). These performance results are then used to provide simple recommendations of the optimally-performing framework given a particular algorithm and problem size.
% We have developed a simple model of hardware and its correlation with performance to predict performance on other architectures

%\bibliographystyle{acm}
\bibliographystyle{IEEEtran}
\bibliography{../drp}
\end{document}